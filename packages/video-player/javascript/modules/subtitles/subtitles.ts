// modules/subtitles/subtitles.ts
import videojs from 'video.js';
import type Player from 'video.js/dist/types/player';
import type HTMLTrackElement from 'video.js/dist/types/tracks/html-track-element.d.ts';
import type { AutoGeneratedTextTrackOptions, RemoteTextTrackOptions, SourceOptions, TextTrackOptions } from '../../interfaces';
// import { Parser } from 'vtt.js'; // Import Parser from vtt.js


declare module 'video.js' {
    interface HtmlTrackElement {
        // Video.js exposes trackEl.track as a TextTrack
        track: TextTrack;
    }
}
  

// declare global {
//     interface Window {
//         WebVTT: {
//             Parser: typeof Parser;         // you can import Parser’s type from vtt.js if available
//             StringDecoder: () => any;
//         };
//     }
// }


// Word‐level transcript entry
interface WordTiming {
    word: string;
    start_time: number;
    end_time: number;
}

// Full transcript JSON entry
interface TranscriptEntry {
    transcript: string;
    confidence: number;
    words: WordTiming[];
    language?: string;
}

// Exported for testing purposes
export const log = videojs.log.createLogger('videojs-playlist');

// Setup subtitles: fetch or parse, build VTTCues, optional highlighting
async function setupSubtitles(params: {
    player: Player;
    opts: RemoteTextTrackOptions;
    currentSource?: SourceOptions;
}): Promise<TextTrackOptions> {
    let { player, opts, currentSource } = params;
    const { maxWords = 4, wordHighlight } = opts;

    // artifical delay to simulate loading
    // await new Promise(resolve => setTimeout(resolve, 10000));

    // 1️. Fetch the transcript JSON
    // const raw = await fetch(currentSource.src!).then(r => {
    //     if (!r.ok) throw new Error('Failed to fetch transcript');
    //     return r.text();
    // });
    const raw = [{ "transcript": " We're going to have a previous EVO Champion in all of our matches here.", "confidence": 0.5750714285714286, "words": [{ "word": "We're", "start_time": 0.08, "end_time": 0.201 }, { "word": "going", "start_time": 0.261, "end_time": 0.503 }, { "word": "to", "start_time": 0.523, "end_time": 0.603 }, { "word": "have", "start_time": 0.623, "end_time": 0.965 }, { "word": "a", "start_time": 0.985, "end_time": 1.046 }, { "word": "previous", "start_time": 1.388, "end_time": 1.81 }, { "word": "EVO", "start_time": 1.87, "end_time": 2.051 }, { "word": "Champion", "start_time": 2.112, "end_time": 2.554 }, { "word": "in", "start_time": 2.594, "end_time": 2.675 }, { "word": "all", "start_time": 2.816, "end_time": 2.936 }, { "word": "of", "start_time": 2.956, "end_time": 2.997 }, { "word": "our", "start_time": 3.077, "end_time": 3.157 }, { "word": "matches", "start_time": 3.178, "end_time": 3.499 }, { "word": "here.", "start_time": 3.519, "end_time": 3.62 }], "alternatives": [], "language": "en" }, { "transcript": " This is actually a very similar situation, right?", "confidence": 0.6392499999999999, "words": [{ "word": "This", "start_time": 3.903, "end_time": 4.004 }, { "word": "is", "start_time": 4.044, "end_time": 4.125 }, { "word": "actually", "start_time": 4.186, "end_time": 4.429 }, { "word": "a", "start_time": 4.45, "end_time": 4.47 }, { "word": "very", "start_time": 4.51, "end_time": 4.632 }, { "word": "similar", "start_time": 4.672, "end_time": 4.875 }, { "word": "situation,", "start_time": 4.895, "end_time": 5.118 }, { "word": "right?", "start_time": 5.138, "end_time": 5.24 }], "alternatives": [], "language": "en" }, { "transcript": " Previous EVO Champion versus a player from another country", "confidence": 0.6956666666666665, "words": [{ "word": "Previous", "start_time": 5.601, "end_time": 5.924 }, { "word": "EVO", "start_time": 6.004, "end_time": 6.185 }, { "word": "Champion", "start_time": 6.225, "end_time": 6.668 }, { "word": "versus", "start_time": 6.809, "end_time": 7.212 }, { "word": "a", "start_time": 7.232, "end_time": 7.252 }, { "word": "player", "start_time": 7.453, "end_time": 7.735 }, { "word": "from", "start_time": 7.776, "end_time": 7.916 }, { "word": "another", "start_time": 7.977, "end_time": 8.198 }, { "word": "country", "start_time": 8.239, "end_time": 8.46 }], "alternatives": [], "language": "en" }, { "transcript": " that has been proven to be one of the best players in the entire world", "confidence": 0.7933999999999999, "words": [{ "word": "that", "start_time": 8.661, "end_time": 8.782 }, { "word": "has", "start_time": 8.802, "end_time": 8.943 }, { "word": "been", "start_time": 9.244, "end_time": 9.405 }, { "word": "proven", "start_time": 9.727, "end_time": 10.149 }, { "word": "to", "start_time": 10.21, "end_time": 10.29 }, { "word": "be", "start_time": 10.31, "end_time": 10.431 }, { "word": "one", "start_time": 10.511, "end_time": 10.592 }, { "word": "of", "start_time": 10.612, "end_time": 10.652 }, { "word": "the", "start_time": 10.672, "end_time": 10.733 }, { "word": "best", "start_time": 10.773, "end_time": 10.914 }, { "word": "players", "start_time": 10.954, "end_time": 11.235 }, { "word": "in", "start_time": 11.296, "end_time": 11.356 }, { "word": "the", "start_time": 11.376, "end_time": 11.457 }, { "word": "entire", "start_time": 11.497, "end_time": 11.879 }, { "word": "world", "start_time": 11.939, "end_time": 12.06 }], "alternatives": [], "language": "en" }, { "transcript": " time and time again.", "confidence": 0.70325, "words": [{ "word": "time", "start_time": 12.783, "end_time": 12.989 }, { "word": "and", "start_time": 13.01, "end_time": 13.072 }, { "word": "time", "start_time": 13.113, "end_time": 13.236 }, { "word": "again.", "start_time": 13.257, "end_time": 13.36 }], "alternatives": [], "language": "en" }, { "transcript": " So this is a great one to see.", "confidence": 0.698625, "words": [{ "word": "So", "start_time": 13.601, "end_time": 13.742 }, { "word": "this", "start_time": 13.763, "end_time": 13.944 }, { "word": "is", "start_time": 14.147, "end_time": 14.227 }, { "word": "a", "start_time": 14.248, "end_time": 14.268 }, { "word": "great", "start_time": 14.732, "end_time": 15.076 }, { "word": "one", "start_time": 15.137, "end_time": 15.238 }, { "word": "to", "start_time": 15.278, "end_time": 15.339 }, { "word": "see.", "start_time": 15.359, "end_time": 15.46 }], "alternatives": [], "language": "en" }, { "transcript": " And Sonic Fox, you know, kind of, I think a lot of people were unsure how they were going to be playing throughout today.", "confidence": 0.6255416666666668, "words": [{ "word": "And", "start_time": 16.071, "end_time": 16.192 }, { "word": "Sonic", "start_time": 16.733, "end_time": 17.014 }, { "word": "Fox,", "start_time": 17.034, "end_time": 17.235 }, { "word": "you", "start_time": 17.255, "end_time": 17.335 }, { "word": "know,", "start_time": 17.355, "end_time": 17.476 }, { "word": "kind", "start_time": 17.958, "end_time": 18.198 }, { "word": "of,", "start_time": 18.259, "end_time": 18.299 }, { "word": "I", "start_time": 18.319, "end_time": 18.339 }, { "word": "think", "start_time": 18.359, "end_time": 18.961 }, { "word": "a", "start_time": 19.001, "end_time": 19.021 }, { "word": "lot", "start_time": 19.041, "end_time": 19.142 }, { "word": "of", "start_time": 19.162, "end_time": 19.222 }, { "word": "people", "start_time": 19.242, "end_time": 19.402 }, { "word": "were", "start_time": 19.422, "end_time": 19.563 }, { "word": "unsure", "start_time": 19.643, "end_time": 20.025 }, { "word": "how", "start_time": 20.105, "end_time": 20.245 }, { "word": "they", "start_time": 20.285, "end_time": 20.386 }, { "word": "were", "start_time": 20.406, "end_time": 20.526 }, { "word": "going", "start_time": 20.546, "end_time": 20.687 }, { "word": "to", "start_time": 20.707, "end_time": 20.747 }, { "word": "be", "start_time": 20.787, "end_time": 20.867 }, { "word": "playing", "start_time": 20.928, "end_time": 21.269 }, { "word": "throughout", "start_time": 21.289, "end_time": 21.53 }, { "word": "today.", "start_time": 21.55, "end_time": 21.65 }], "alternatives": [], "language": "en" }, { "transcript": " There are a lot of games to focus on at this EVO, including Skullgirls, of course, which is, Sonic Fox is like tried and true, but obviously one match away from winner's top eight, so they're doing pretty well.", "confidence": 0.7377692307692306, "words": [{ "word": "There", "start_time": 22.311, "end_time": 22.411 }, { "word": "are", "start_time": 22.431, "end_time": 22.491 }, { "word": "a", "start_time": 22.511, "end_time": 22.531 }, { "word": "lot", "start_time": 22.591, "end_time": 22.752 }, { "word": "of", "start_time": 22.772, "end_time": 22.832 }, { "word": "games", "start_time": 22.912, "end_time": 23.313 }, { "word": "to", "start_time": 23.453, "end_time": 23.693 }, { "word": "focus", "start_time": 23.834, "end_time": 24.174 }, { "word": "on", "start_time": 24.295, "end_time": 24.395 }, { "word": "at", "start_time": 24.435, "end_time": 24.495 }, { "word": "this", "start_time": 24.535, "end_time": 24.675 }, { "word": "EVO,", "start_time": 24.816, "end_time": 25.116 }, { "word": "including", "start_time": 25.196, "end_time": 25.577 }, { "word": "Skullgirls,", "start_time": 25.617, "end_time": 26.038 }, { "word": "of", "start_time": 26.078, "end_time": 26.138 }, { "word": "course,", "start_time": 26.178, "end_time": 26.399 }, { "word": "which", "start_time": 26.439, "end_time": 26.579 }, { "word": "is,", "start_time": 26.759, "end_time": 26.879 }, { "word": "Sonic", "start_time": 27.24, "end_time": 27.481 }, { "word": "Fox", "start_time": 27.501, "end_time": 27.661 }, { "word": "is", "start_time": 27.701, "end_time": 27.781 }, { "word": "like", "start_time": 27.801, "end_time": 27.921 }, { "word": "tried", "start_time": 27.982, "end_time": 28.282 }, { "word": "and", "start_time": 28.302, "end_time": 28.382 }, { "word": "true,", "start_time": 28.422, "end_time": 28.683 }, { "word": "but", "start_time": 29.104, "end_time": 29.344 }, { "word": "obviously", "start_time": 29.845, "end_time": 30.226 }, { "word": "one", "start_time": 30.286, "end_time": 30.366 }, { "word": "match", "start_time": 30.386, "end_time": 30.546 }, { "word": "away", "start_time": 30.566, "end_time": 30.687 }, { "word": "from", "start_time": 30.707, "end_time": 30.787 }, { "word": "winner's", "start_time": 30.827, "end_time": 31.007 }, { "word": "top", "start_time": 31.027, "end_time": 31.228 }, { "word": "eight,", "start_time": 31.288, "end_time": 31.448 }, { "word": "so", "start_time": 31.508, "end_time": 31.729 }, { "word": "they're", "start_time": 31.789, "end_time": 32.009 }, { "word": "doing", "start_time": 32.029, "end_time": 32.169 }, { "word": "pretty", "start_time": 32.19, "end_time": 32.31 }, { "word": "well.", "start_time": 32.33, "end_time": 32.45 }], "alternatives": [], "language": "en" }, { "transcript": " Well, I would say.", "confidence": 0.61975, "words": [{ "word": "Well,", "start_time": 32.583, "end_time": 32.829 }, { "word": "I", "start_time": 32.912, "end_time": 32.973 }, { "word": "would", "start_time": 32.994, "end_time": 33.138 }, { "word": "say.", "start_time": 33.158, "end_time": 33.22 }], "alternatives": [], "language": "en" }, { "transcript": " Yeah, SonicFox, it's interesting because when", "confidence": 0.6903333333333332, "words": [{ "word": "Yeah,", "start_time": 33.843, "end_time": 34.085 }, { "word": "SonicFox,", "start_time": 34.125, "end_time": 34.649 }, { "word": "it's", "start_time": 35.152, "end_time": 35.293 }, { "word": "interesting", "start_time": 35.354, "end_time": 35.756 }, { "word": "because", "start_time": 35.797, "end_time": 36.079 }, { "word": "when", "start_time": 36.099, "end_time": 36.179 }], "alternatives": [], "language": "en" }]
    const entries = raw as TranscriptEntry[];

    // 2. Flatten into word list
    // @ts-ignore
    const allWords = entries.flatMap(e => e.words);

    // 3. Build WebVTT string
    let vtt = 'WEBVTT\n\n';

    const fmt = (sec: number) => {
        const ms = Math.floor((sec % 1) * 1000).toString().padStart(3, '0');
        const s = Math.floor(sec % 60).toString().padStart(2, '0');
        const m = Math.floor((sec / 60) % 60).toString().padStart(2, '0');
        const h = Math.floor(sec / 3600).toString().padStart(2, '0');
        return `${h}:${m}:${s}.${ms}`;
    };

    for (let i = 0; i < allWords.length; i += maxWords) {
        const block = allWords.slice(i, i + maxWords);
        const start = fmt(block[0].start_time);
        const end = fmt(block[block.length - 1].end_time);

        // Wrap each word in a span for highlighting
        const text = block
            .map((w, idx) => `<c.word-${i + idx}>${w.word}</c>`)
            .join(' ');

        vtt += `${start} --> ${end}\n${text}\n\n`;
    }

    // 4️. Create a blob URL
    const blob = new Blob([vtt], { type: 'text/vtt' });
    const srcUrl = URL.createObjectURL(blob);
    opts = {
        src: srcUrl,
        kind: 'subtitles',
        srclang: entries[0].language || 'en',
        label: 'AI Gen Subtitles',
        default: true,
    }

    if (wordHighlight) {
        let subtitleSyncInterval: any;

        player.on('play', () => {
            subtitleSyncInterval = setInterval(() => {
                const time = player.currentTime();
                const display = player.el().querySelector('.vjs-text-track-display');
                if (!display) return;

                display.querySelectorAll('span[class^="word-"], span[class*=" word-"]').forEach(el => {
                    const cls = Array.from(el.classList)
                        .find(c => c.startsWith('word-'))!;
                    const idx = Number(cls.split('-')[1]);
                    const w = allWords[idx];
                    el.classList.toggle('vjs-word-highlight', (time ?? 0) >= w.start_time && (time ?? 0) <= w.end_time);
                });
            }, 50); // every 100ms
        });

        player.on('pause', () => {
            clearInterval(subtitleSyncInterval);
        });
        player.on('ended', () => {
            clearInterval(subtitleSyncInterval);
        });
    }
    return opts;
}

function hasSrc(opts: RemoteTextTrackOptions): opts is TextTrackOptions & { src: string } {
    return typeof (opts as any).src === 'string';
}

function isAutoGenerate(opts: RemoteTextTrackOptions): opts is AutoGeneratedTextTrackOptions {
    return (opts as any).autoGenerateSubtitles === true;
}


export function validateRemoteTextTrackOptions(opts: RemoteTextTrackOptions): void {
    // Invalid: src/kind/srclang/label with auto-generation
    if (isAutoGenerate(opts)) {
        const conflicting = ['src', 'kind', 'srclang', 'label'].filter(key => key in opts);
        if (conflicting.length > 0) {
            throw new Error(
                `Invalid RemoteTextTrackOptions: Cannot specify [${conflicting.join(', ')}] when autoGenerateSubtitles is true.`
            );
        }

        if (opts.translate?.length && (opts.maxWords || opts.wordHighlight)) {
            throw new Error(
                `Invalid RemoteTextTrackOptions: Cannot use maxWords or wordHighlight when translate is provided.`
            );
        }
    }
    // Invalid: if src is not a transcript URL, and maxWords/wordHighlight is set
    if (hasSrc(opts) && (opts.maxWords || opts.wordHighlight)) {
        const srcURL = new URL(opts.src);
        const isTranscript = srcURL.pathname.endsWith('.transcript');
        if (!isTranscript) {
            throw new Error(
                `Invalid RemoteTextTrackOptions: src must be a transcript URL when using maxWords or wordHighlight.`
            );
        }
    }
}


export function overrideAddRemoteTextTrack(
    player: Player) {
    const orig = player.addRemoteTextTrack.bind(player);

    player.addRemoteTextTrack = (
        options: RemoteTextTrackOptions,
        manualCleanup?: boolean
    ) => {

        // 1) Validate options
        try {
            validateRemoteTextTrackOptions(options);
        } catch (err) {
            player.error(err instanceof Error ? err.message : String(err));
        }

        // 2) Check if src is a transcript URL
        const srcURL = hasSrc(options) ? new URL(options.src) : null;
        const isTranscript = srcURL && srcURL.pathname.endsWith('.transcript');

        // 3) Create the track element immediately 
        const trackEl = orig({
            kind: 'subtitles',
            src: 'src' in options && !isTranscript && options.src || '',
            srclang: 'srclang' in options && options.srclang || 'en',
            label: 'label' in options && options.label || 'Loading…',
            default: options.default ?? false,
        }, manualCleanup) as HTMLTrackElement;

        // 4) if we need to auto‐generate, fire off the async work now
        if (isAutoGenerate(options) || isTranscript) {
            setupSubtitles({ player: player, opts: options })
                .then(async (finalOpts) => {
                    // finalOpts.src is a Blob URL with your full VTT 
                    const src = finalOpts.src!;
                    const vttText = await fetch(src).then(r => r.text());

                    // 3) parse the VTT yourself and add cues to the same TextTrack
                    //    (video.js bundles vtt.js under window.WebVTT)
                    const parser = new (window as any).WebVTT.Parser(
                        window,
                        //@ts-ignore    
                        WebVTT.StringDecoder()
                    );
                    const cues: TextTrackCue[] = [];
                    parser.oncue = (c: TextTrackCue) => cues.push(c);
                    parser.parse(vttText);
                    parser.flush();

                    // 4) clear out the “Loading…” label and replace with your real one
                    trackEl.label = finalOpts.label;
                    trackEl.srclang = finalOpts.srclang;
                    // 5) enable the track
                    //@ts-ignore    
                    trackEl.track!.mode = 'hidden';

                    // 6) add all the real cues
                    //@ts-ignore    
                    cues.forEach(cue => trackEl.track!.addCue(cue));
                    //@ts-ignore   
                    trackEl.track.default = true;
                    //@ts-ignore  
                    trackEl.track.label = finalOpts.label;

                    //@ts-ignore  
                    const tt = trackEl.track!;

                    // 1) force it to show
                    tt.mode = 'showing';

                    // 2) turn _off_ every other textTrack so yours is the only one
                    //@ts-ignore  
                    for (const other of Array.from(player.textTracks())) {
                        if (other !== tt) {
                            //@ts-ignore  
                            other.mode = 'disabled';
                        }
                    }

                    // 7) finally, rebuild the Subs/Caps button so it picks up the new label/default
                    // @ts-ignore
                    const ccButton = player.controlBar.getChild('SubsCapsButton') as any;
                    if (ccButton && typeof ccButton.update === 'function') {
                        ccButton.update();
                    }
                })
                .catch(err => {
                    player.error(err instanceof Error ? err.message : String(err));
                });
        }

        // 7) return the *same* HTMLTrackElement you just mutated later
        return trackEl;
    };
}